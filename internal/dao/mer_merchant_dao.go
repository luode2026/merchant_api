// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"merchant_api/internal/model"
)

func newMerMerchant(db *gorm.DB, opts ...gen.DOOption) merMerchant {
	_merMerchant := merMerchant{}

	_merMerchant.merMerchantDo.UseDB(db, opts...)
	_merMerchant.merMerchantDo.UseModel(&model.MerMerchant{})

	tableName := _merMerchant.merMerchantDo.TableName()
	_merMerchant.ALL = field.NewAsterisk(tableName)
	_merMerchant.MerID = field.NewInt32(tableName, "mer_id")
	_merMerchant.CategoryIds = field.NewString(tableName, "category_ids")
	_merMerchant.MerName = field.NewString(tableName, "mer_name")
	_merMerchant.RealName = field.NewString(tableName, "real_name")
	_merMerchant.MerPhone = field.NewString(tableName, "mer_phone")
	_merMerchant.MerAddress = field.NewString(tableName, "mer_address")
	_merMerchant.MerKeyword = field.NewString(tableName, "mer_keyword")
	_merMerchant.MerLogo = field.NewString(tableName, "mer_logo")
	_merMerchant.MerBanner = field.NewString(tableName, "mer_banner")
	_merMerchant.OpeningTime = field.NewTime(tableName, "opening_time")
	_merMerchant.ClosingTime = field.NewTime(tableName, "closing_time")
	_merMerchant.Sales = field.NewInt32(tableName, "sales")
	_merMerchant.Mark = field.NewString(tableName, "mark")
	_merMerchant.Sort = field.NewInt32(tableName, "sort")
	_merMerchant.Status = field.NewBool(tableName, "status")
	_merMerchant.IsDel = field.NewInt32(tableName, "is_del")
	_merMerchant.MerInfo = field.NewString(tableName, "mer_info")
	_merMerchant.ServicePhone = field.NewString(tableName, "service_phone")
	_merMerchant.CreateAt = field.NewTime(tableName, "create_at")
	_merMerchant.UpdateAt = field.NewTime(tableName, "update_at")
	_merMerchant.MerMoney = field.NewFloat64(tableName, "mer_money")
	_merMerchant.BankName = field.NewString(tableName, "bank_name")
	_merMerchant.BankCode = field.NewString(tableName, "bank_code")
	_merMerchant.WalletAddress = field.NewString(tableName, "wallet_address")
	_merMerchant.DeliveryWay = field.NewString(tableName, "delivery_way")

	_merMerchant.fillFieldMap()

	return _merMerchant
}

// merMerchant 商户表
type merMerchant struct {
	merMerchantDo

	ALL           field.Asterisk
	MerID         field.Int32  // 商户id
	CategoryIds   field.String // 商户分类 id
	MerName       field.String // 商户名称
	RealName      field.String // 商户姓名
	MerPhone      field.String // 商户手机号
	MerAddress    field.String // 商户地址
	MerKeyword    field.String // 商户关键字
	MerLogo       field.String // 商户头像/logo
	MerBanner     field.String // 商户banner图片
	OpeningTime   field.Time   // 营业开始时间
	ClosingTime   field.Time   // 营业结束时间
	Sales         field.Int32  // 销量
	Mark          field.String // 商户备注
	Sort          field.Int32
	Status        field.Bool   // 商户是否禁用0锁定,1正常
	IsDel         field.Int32  // 0未删除1删除
	MerInfo       field.String // 店铺简介
	ServicePhone  field.String // 店铺电话
	CreateAt      field.Time
	UpdateAt      field.Time
	MerMoney      field.Float64 // 商户余额
	BankName      field.String  // 银行名称
	BankCode      field.String  // 银行卡转账信息
	WalletAddress field.String  // 钱包地址
	DeliveryWay   field.String  // 配送方式

	fieldMap map[string]field.Expr
}

func (m merMerchant) Table(newTableName string) *merMerchant {
	m.merMerchantDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m merMerchant) As(alias string) *merMerchant {
	m.merMerchantDo.DO = *(m.merMerchantDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *merMerchant) updateTableName(table string) *merMerchant {
	m.ALL = field.NewAsterisk(table)
	m.MerID = field.NewInt32(table, "mer_id")
	m.CategoryIds = field.NewString(table, "category_ids")
	m.MerName = field.NewString(table, "mer_name")
	m.RealName = field.NewString(table, "real_name")
	m.MerPhone = field.NewString(table, "mer_phone")
	m.MerAddress = field.NewString(table, "mer_address")
	m.MerKeyword = field.NewString(table, "mer_keyword")
	m.MerLogo = field.NewString(table, "mer_logo")
	m.MerBanner = field.NewString(table, "mer_banner")
	m.OpeningTime = field.NewTime(table, "opening_time")
	m.ClosingTime = field.NewTime(table, "closing_time")
	m.Sales = field.NewInt32(table, "sales")
	m.Mark = field.NewString(table, "mark")
	m.Sort = field.NewInt32(table, "sort")
	m.Status = field.NewBool(table, "status")
	m.IsDel = field.NewInt32(table, "is_del")
	m.MerInfo = field.NewString(table, "mer_info")
	m.ServicePhone = field.NewString(table, "service_phone")
	m.CreateAt = field.NewTime(table, "create_at")
	m.UpdateAt = field.NewTime(table, "update_at")
	m.MerMoney = field.NewFloat64(table, "mer_money")
	m.BankName = field.NewString(table, "bank_name")
	m.BankCode = field.NewString(table, "bank_code")
	m.WalletAddress = field.NewString(table, "wallet_address")
	m.DeliveryWay = field.NewString(table, "delivery_way")

	m.fillFieldMap()

	return m
}

func (m *merMerchant) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *merMerchant) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 25)
	m.fieldMap["mer_id"] = m.MerID
	m.fieldMap["category_ids"] = m.CategoryIds
	m.fieldMap["mer_name"] = m.MerName
	m.fieldMap["real_name"] = m.RealName
	m.fieldMap["mer_phone"] = m.MerPhone
	m.fieldMap["mer_address"] = m.MerAddress
	m.fieldMap["mer_keyword"] = m.MerKeyword
	m.fieldMap["mer_logo"] = m.MerLogo
	m.fieldMap["mer_banner"] = m.MerBanner
	m.fieldMap["opening_time"] = m.OpeningTime
	m.fieldMap["closing_time"] = m.ClosingTime
	m.fieldMap["sales"] = m.Sales
	m.fieldMap["mark"] = m.Mark
	m.fieldMap["sort"] = m.Sort
	m.fieldMap["status"] = m.Status
	m.fieldMap["is_del"] = m.IsDel
	m.fieldMap["mer_info"] = m.MerInfo
	m.fieldMap["service_phone"] = m.ServicePhone
	m.fieldMap["create_at"] = m.CreateAt
	m.fieldMap["update_at"] = m.UpdateAt
	m.fieldMap["mer_money"] = m.MerMoney
	m.fieldMap["bank_name"] = m.BankName
	m.fieldMap["bank_code"] = m.BankCode
	m.fieldMap["wallet_address"] = m.WalletAddress
	m.fieldMap["delivery_way"] = m.DeliveryWay
}

func (m merMerchant) clone(db *gorm.DB) merMerchant {
	m.merMerchantDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m merMerchant) replaceDB(db *gorm.DB) merMerchant {
	m.merMerchantDo.ReplaceDB(db)
	return m
}

type merMerchantDo struct{ gen.DO }

type IMerMerchantDo interface {
	gen.SubQuery
	Debug() IMerMerchantDo
	WithContext(ctx context.Context) IMerMerchantDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMerMerchantDo
	WriteDB() IMerMerchantDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMerMerchantDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMerMerchantDo
	Not(conds ...gen.Condition) IMerMerchantDo
	Or(conds ...gen.Condition) IMerMerchantDo
	Select(conds ...field.Expr) IMerMerchantDo
	Where(conds ...gen.Condition) IMerMerchantDo
	Order(conds ...field.Expr) IMerMerchantDo
	Distinct(cols ...field.Expr) IMerMerchantDo
	Omit(cols ...field.Expr) IMerMerchantDo
	Join(table schema.Tabler, on ...field.Expr) IMerMerchantDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMerMerchantDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMerMerchantDo
	Group(cols ...field.Expr) IMerMerchantDo
	Having(conds ...gen.Condition) IMerMerchantDo
	Limit(limit int) IMerMerchantDo
	Offset(offset int) IMerMerchantDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMerMerchantDo
	Unscoped() IMerMerchantDo
	Create(values ...*model.MerMerchant) error
	CreateInBatches(values []*model.MerMerchant, batchSize int) error
	Save(values ...*model.MerMerchant) error
	First() (*model.MerMerchant, error)
	Take() (*model.MerMerchant, error)
	Last() (*model.MerMerchant, error)
	Find() ([]*model.MerMerchant, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MerMerchant, err error)
	FindInBatches(result *[]*model.MerMerchant, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.MerMerchant) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMerMerchantDo
	Assign(attrs ...field.AssignExpr) IMerMerchantDo
	Joins(fields ...field.RelationField) IMerMerchantDo
	Preload(fields ...field.RelationField) IMerMerchantDo
	FirstOrInit() (*model.MerMerchant, error)
	FirstOrCreate() (*model.MerMerchant, error)
	FindByPage(offset int, limit int) (result []*model.MerMerchant, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMerMerchantDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m merMerchantDo) Debug() IMerMerchantDo {
	return m.withDO(m.DO.Debug())
}

func (m merMerchantDo) WithContext(ctx context.Context) IMerMerchantDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m merMerchantDo) ReadDB() IMerMerchantDo {
	return m.Clauses(dbresolver.Read)
}

func (m merMerchantDo) WriteDB() IMerMerchantDo {
	return m.Clauses(dbresolver.Write)
}

func (m merMerchantDo) Session(config *gorm.Session) IMerMerchantDo {
	return m.withDO(m.DO.Session(config))
}

func (m merMerchantDo) Clauses(conds ...clause.Expression) IMerMerchantDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m merMerchantDo) Returning(value interface{}, columns ...string) IMerMerchantDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m merMerchantDo) Not(conds ...gen.Condition) IMerMerchantDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m merMerchantDo) Or(conds ...gen.Condition) IMerMerchantDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m merMerchantDo) Select(conds ...field.Expr) IMerMerchantDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m merMerchantDo) Where(conds ...gen.Condition) IMerMerchantDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m merMerchantDo) Order(conds ...field.Expr) IMerMerchantDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m merMerchantDo) Distinct(cols ...field.Expr) IMerMerchantDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m merMerchantDo) Omit(cols ...field.Expr) IMerMerchantDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m merMerchantDo) Join(table schema.Tabler, on ...field.Expr) IMerMerchantDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m merMerchantDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMerMerchantDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m merMerchantDo) RightJoin(table schema.Tabler, on ...field.Expr) IMerMerchantDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m merMerchantDo) Group(cols ...field.Expr) IMerMerchantDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m merMerchantDo) Having(conds ...gen.Condition) IMerMerchantDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m merMerchantDo) Limit(limit int) IMerMerchantDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m merMerchantDo) Offset(offset int) IMerMerchantDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m merMerchantDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMerMerchantDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m merMerchantDo) Unscoped() IMerMerchantDo {
	return m.withDO(m.DO.Unscoped())
}

func (m merMerchantDo) Create(values ...*model.MerMerchant) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m merMerchantDo) CreateInBatches(values []*model.MerMerchant, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m merMerchantDo) Save(values ...*model.MerMerchant) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m merMerchantDo) First() (*model.MerMerchant, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.MerMerchant), nil
	}
}

func (m merMerchantDo) Take() (*model.MerMerchant, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.MerMerchant), nil
	}
}

func (m merMerchantDo) Last() (*model.MerMerchant, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.MerMerchant), nil
	}
}

func (m merMerchantDo) Find() ([]*model.MerMerchant, error) {
	result, err := m.DO.Find()
	return result.([]*model.MerMerchant), err
}

func (m merMerchantDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MerMerchant, err error) {
	buf := make([]*model.MerMerchant, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m merMerchantDo) FindInBatches(result *[]*model.MerMerchant, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m merMerchantDo) Attrs(attrs ...field.AssignExpr) IMerMerchantDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m merMerchantDo) Assign(attrs ...field.AssignExpr) IMerMerchantDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m merMerchantDo) Joins(fields ...field.RelationField) IMerMerchantDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m merMerchantDo) Preload(fields ...field.RelationField) IMerMerchantDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m merMerchantDo) FirstOrInit() (*model.MerMerchant, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.MerMerchant), nil
	}
}

func (m merMerchantDo) FirstOrCreate() (*model.MerMerchant, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.MerMerchant), nil
	}
}

func (m merMerchantDo) FindByPage(offset int, limit int) (result []*model.MerMerchant, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m merMerchantDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m merMerchantDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m merMerchantDo) Delete(models ...*model.MerMerchant) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *merMerchantDo) withDO(do gen.Dao) *merMerchantDo {
	m.DO = *do.(*gen.DO)
	return m
}

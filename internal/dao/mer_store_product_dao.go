// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"merchant_api/internal/model"
)

func newMerStoreProduct(db *gorm.DB, opts ...gen.DOOption) merStoreProduct {
	_merStoreProduct := merStoreProduct{}

	_merStoreProduct.merStoreProductDo.UseDB(db, opts...)
	_merStoreProduct.merStoreProductDo.UseModel(&model.MerStoreProduct{})

	tableName := _merStoreProduct.merStoreProductDo.TableName()
	_merStoreProduct.ALL = field.NewAsterisk(tableName)
	_merStoreProduct.ProductID = field.NewInt32(tableName, "product_id")
	_merStoreProduct.MerID = field.NewInt32(tableName, "mer_id")
	_merStoreProduct.StoreName = field.NewString(tableName, "store_name")
	_merStoreProduct.StoreInfo = field.NewString(tableName, "store_info")
	_merStoreProduct.Keyword = field.NewString(tableName, "keyword")
	_merStoreProduct.IsShow = field.NewInt32(tableName, "is_show")
	_merStoreProduct.IsDel = field.NewInt32(tableName, "is_del")
	_merStoreProduct.MerStatus = field.NewBool(tableName, "mer_status")
	_merStoreProduct.CateID = field.NewInt32(tableName, "cate_id")
	_merStoreProduct.UnitName = field.NewString(tableName, "unit_name")
	_merStoreProduct.Sort = field.NewInt32(tableName, "sort")
	_merStoreProduct.Sales = field.NewInt32(tableName, "sales")
	_merStoreProduct.Price = field.NewFloat64(tableName, "price")
	_merStoreProduct.Cost = field.NewFloat64(tableName, "cost")
	_merStoreProduct.OtPrice = field.NewFloat64(tableName, "ot_price")
	_merStoreProduct.Stock = field.NewInt32(tableName, "stock")
	_merStoreProduct.IsGood = field.NewBool(tableName, "is_good")
	_merStoreProduct.ProductType = field.NewInt32(tableName, "product_type")
	_merStoreProduct.CreateAt = field.NewTime(tableName, "create_at")
	_merStoreProduct.Image = field.NewString(tableName, "image")
	_merStoreProduct.SliderImage = field.NewString(tableName, "slider_image")
	_merStoreProduct.Extend = field.NewString(tableName, "extend")
	_merStoreProduct.RefundSwitch = field.NewInt32(tableName, "refund_switch")
	_merStoreProduct.Delete_ = field.NewInt32(tableName, "delete")
	_merStoreProduct.AutoOnTime = field.NewInt32(tableName, "auto_on_time")
	_merStoreProduct.BarCodeNumber = field.NewString(tableName, "bar_code_number")

	_merStoreProduct.fillFieldMap()

	return _merStoreProduct
}

// merStoreProduct 商品表
type merStoreProduct struct {
	merStoreProductDo

	ALL           field.Asterisk
	ProductID     field.Int32   // 商品id
	MerID         field.Int32   // 商户Id
	StoreName     field.String  // 商品名称
	StoreInfo     field.String  // 商品简介
	Keyword       field.String  // 关键字
	IsShow        field.Int32   // 商户 状态（0:未上架，1:上架，2:定时上架）
	IsDel         field.Int32   // 是否删除
	MerStatus     field.Bool    // 商铺状态是否 1.正常 0. 非正常
	CateID        field.Int32   // 分类id
	UnitName      field.String  // 单位名
	Sort          field.Int32   // 排序
	Sales         field.Int32   // 销量
	Price         field.Float64 // 最低价格
	Cost          field.Float64 // 成本价
	OtPrice       field.Float64 // 原价
	Stock         field.Int32   // 总库存
	IsGood        field.Bool    // 是否优品推荐
	ProductType   field.Int32   // 0.普通商品 1.秒杀商品,2.预售商品，3.助力商品，4.拼团商品
	CreateAt      field.Time    // 添加时间
	Image         field.String  // 商品图片
	SliderImage   field.String  // 轮播图
	Extend        field.String  // 扩展信息
	RefundSwitch  field.Int32   // 是否支持退款
	Delete_       field.Int32
	AutoOnTime    field.Int32  // 自动上架时间
	BarCodeNumber field.String // 商品条码

	fieldMap map[string]field.Expr
}

func (m merStoreProduct) Table(newTableName string) *merStoreProduct {
	m.merStoreProductDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m merStoreProduct) As(alias string) *merStoreProduct {
	m.merStoreProductDo.DO = *(m.merStoreProductDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *merStoreProduct) updateTableName(table string) *merStoreProduct {
	m.ALL = field.NewAsterisk(table)
	m.ProductID = field.NewInt32(table, "product_id")
	m.MerID = field.NewInt32(table, "mer_id")
	m.StoreName = field.NewString(table, "store_name")
	m.StoreInfo = field.NewString(table, "store_info")
	m.Keyword = field.NewString(table, "keyword")
	m.IsShow = field.NewInt32(table, "is_show")
	m.IsDel = field.NewInt32(table, "is_del")
	m.MerStatus = field.NewBool(table, "mer_status")
	m.CateID = field.NewInt32(table, "cate_id")
	m.UnitName = field.NewString(table, "unit_name")
	m.Sort = field.NewInt32(table, "sort")
	m.Sales = field.NewInt32(table, "sales")
	m.Price = field.NewFloat64(table, "price")
	m.Cost = field.NewFloat64(table, "cost")
	m.OtPrice = field.NewFloat64(table, "ot_price")
	m.Stock = field.NewInt32(table, "stock")
	m.IsGood = field.NewBool(table, "is_good")
	m.ProductType = field.NewInt32(table, "product_type")
	m.CreateAt = field.NewTime(table, "create_at")
	m.Image = field.NewString(table, "image")
	m.SliderImage = field.NewString(table, "slider_image")
	m.Extend = field.NewString(table, "extend")
	m.RefundSwitch = field.NewInt32(table, "refund_switch")
	m.Delete_ = field.NewInt32(table, "delete")
	m.AutoOnTime = field.NewInt32(table, "auto_on_time")
	m.BarCodeNumber = field.NewString(table, "bar_code_number")

	m.fillFieldMap()

	return m
}

func (m *merStoreProduct) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *merStoreProduct) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 26)
	m.fieldMap["product_id"] = m.ProductID
	m.fieldMap["mer_id"] = m.MerID
	m.fieldMap["store_name"] = m.StoreName
	m.fieldMap["store_info"] = m.StoreInfo
	m.fieldMap["keyword"] = m.Keyword
	m.fieldMap["is_show"] = m.IsShow
	m.fieldMap["is_del"] = m.IsDel
	m.fieldMap["mer_status"] = m.MerStatus
	m.fieldMap["cate_id"] = m.CateID
	m.fieldMap["unit_name"] = m.UnitName
	m.fieldMap["sort"] = m.Sort
	m.fieldMap["sales"] = m.Sales
	m.fieldMap["price"] = m.Price
	m.fieldMap["cost"] = m.Cost
	m.fieldMap["ot_price"] = m.OtPrice
	m.fieldMap["stock"] = m.Stock
	m.fieldMap["is_good"] = m.IsGood
	m.fieldMap["product_type"] = m.ProductType
	m.fieldMap["create_at"] = m.CreateAt
	m.fieldMap["image"] = m.Image
	m.fieldMap["slider_image"] = m.SliderImage
	m.fieldMap["extend"] = m.Extend
	m.fieldMap["refund_switch"] = m.RefundSwitch
	m.fieldMap["delete"] = m.Delete_
	m.fieldMap["auto_on_time"] = m.AutoOnTime
	m.fieldMap["bar_code_number"] = m.BarCodeNumber
}

func (m merStoreProduct) clone(db *gorm.DB) merStoreProduct {
	m.merStoreProductDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m merStoreProduct) replaceDB(db *gorm.DB) merStoreProduct {
	m.merStoreProductDo.ReplaceDB(db)
	return m
}

type merStoreProductDo struct{ gen.DO }

type IMerStoreProductDo interface {
	gen.SubQuery
	Debug() IMerStoreProductDo
	WithContext(ctx context.Context) IMerStoreProductDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMerStoreProductDo
	WriteDB() IMerStoreProductDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMerStoreProductDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMerStoreProductDo
	Not(conds ...gen.Condition) IMerStoreProductDo
	Or(conds ...gen.Condition) IMerStoreProductDo
	Select(conds ...field.Expr) IMerStoreProductDo
	Where(conds ...gen.Condition) IMerStoreProductDo
	Order(conds ...field.Expr) IMerStoreProductDo
	Distinct(cols ...field.Expr) IMerStoreProductDo
	Omit(cols ...field.Expr) IMerStoreProductDo
	Join(table schema.Tabler, on ...field.Expr) IMerStoreProductDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMerStoreProductDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMerStoreProductDo
	Group(cols ...field.Expr) IMerStoreProductDo
	Having(conds ...gen.Condition) IMerStoreProductDo
	Limit(limit int) IMerStoreProductDo
	Offset(offset int) IMerStoreProductDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMerStoreProductDo
	Unscoped() IMerStoreProductDo
	Create(values ...*model.MerStoreProduct) error
	CreateInBatches(values []*model.MerStoreProduct, batchSize int) error
	Save(values ...*model.MerStoreProduct) error
	First() (*model.MerStoreProduct, error)
	Take() (*model.MerStoreProduct, error)
	Last() (*model.MerStoreProduct, error)
	Find() ([]*model.MerStoreProduct, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MerStoreProduct, err error)
	FindInBatches(result *[]*model.MerStoreProduct, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.MerStoreProduct) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMerStoreProductDo
	Assign(attrs ...field.AssignExpr) IMerStoreProductDo
	Joins(fields ...field.RelationField) IMerStoreProductDo
	Preload(fields ...field.RelationField) IMerStoreProductDo
	FirstOrInit() (*model.MerStoreProduct, error)
	FirstOrCreate() (*model.MerStoreProduct, error)
	FindByPage(offset int, limit int) (result []*model.MerStoreProduct, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMerStoreProductDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m merStoreProductDo) Debug() IMerStoreProductDo {
	return m.withDO(m.DO.Debug())
}

func (m merStoreProductDo) WithContext(ctx context.Context) IMerStoreProductDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m merStoreProductDo) ReadDB() IMerStoreProductDo {
	return m.Clauses(dbresolver.Read)
}

func (m merStoreProductDo) WriteDB() IMerStoreProductDo {
	return m.Clauses(dbresolver.Write)
}

func (m merStoreProductDo) Session(config *gorm.Session) IMerStoreProductDo {
	return m.withDO(m.DO.Session(config))
}

func (m merStoreProductDo) Clauses(conds ...clause.Expression) IMerStoreProductDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m merStoreProductDo) Returning(value interface{}, columns ...string) IMerStoreProductDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m merStoreProductDo) Not(conds ...gen.Condition) IMerStoreProductDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m merStoreProductDo) Or(conds ...gen.Condition) IMerStoreProductDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m merStoreProductDo) Select(conds ...field.Expr) IMerStoreProductDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m merStoreProductDo) Where(conds ...gen.Condition) IMerStoreProductDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m merStoreProductDo) Order(conds ...field.Expr) IMerStoreProductDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m merStoreProductDo) Distinct(cols ...field.Expr) IMerStoreProductDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m merStoreProductDo) Omit(cols ...field.Expr) IMerStoreProductDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m merStoreProductDo) Join(table schema.Tabler, on ...field.Expr) IMerStoreProductDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m merStoreProductDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMerStoreProductDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m merStoreProductDo) RightJoin(table schema.Tabler, on ...field.Expr) IMerStoreProductDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m merStoreProductDo) Group(cols ...field.Expr) IMerStoreProductDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m merStoreProductDo) Having(conds ...gen.Condition) IMerStoreProductDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m merStoreProductDo) Limit(limit int) IMerStoreProductDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m merStoreProductDo) Offset(offset int) IMerStoreProductDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m merStoreProductDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMerStoreProductDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m merStoreProductDo) Unscoped() IMerStoreProductDo {
	return m.withDO(m.DO.Unscoped())
}

func (m merStoreProductDo) Create(values ...*model.MerStoreProduct) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m merStoreProductDo) CreateInBatches(values []*model.MerStoreProduct, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m merStoreProductDo) Save(values ...*model.MerStoreProduct) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m merStoreProductDo) First() (*model.MerStoreProduct, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.MerStoreProduct), nil
	}
}

func (m merStoreProductDo) Take() (*model.MerStoreProduct, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.MerStoreProduct), nil
	}
}

func (m merStoreProductDo) Last() (*model.MerStoreProduct, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.MerStoreProduct), nil
	}
}

func (m merStoreProductDo) Find() ([]*model.MerStoreProduct, error) {
	result, err := m.DO.Find()
	return result.([]*model.MerStoreProduct), err
}

func (m merStoreProductDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MerStoreProduct, err error) {
	buf := make([]*model.MerStoreProduct, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m merStoreProductDo) FindInBatches(result *[]*model.MerStoreProduct, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m merStoreProductDo) Attrs(attrs ...field.AssignExpr) IMerStoreProductDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m merStoreProductDo) Assign(attrs ...field.AssignExpr) IMerStoreProductDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m merStoreProductDo) Joins(fields ...field.RelationField) IMerStoreProductDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m merStoreProductDo) Preload(fields ...field.RelationField) IMerStoreProductDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m merStoreProductDo) FirstOrInit() (*model.MerStoreProduct, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.MerStoreProduct), nil
	}
}

func (m merStoreProductDo) FirstOrCreate() (*model.MerStoreProduct, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.MerStoreProduct), nil
	}
}

func (m merStoreProductDo) FindByPage(offset int, limit int) (result []*model.MerStoreProduct, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m merStoreProductDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m merStoreProductDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m merStoreProductDo) Delete(models ...*model.MerStoreProduct) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *merStoreProductDo) withDO(do gen.Dao) *merStoreProductDo {
	m.DO = *do.(*gen.DO)
	return m
}
